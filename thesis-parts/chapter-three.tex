\chapter{Esempi applicativi}
In questo capitolo viene provata la flessibilità del modello definito nella
sezione \ref{sec:model-def}, offrendo tre diversi esempi di realizzazione di
questo. In queste dimostrazioni sono presenti numerose semplificazioni, che
servono per semplificare lo sviluppo e concentrarsi sui dettagli implementativi
relativi a Protelis. Una di queste è che la simulazione inizia quando la rete ha
già effettuato il meccanismo di discovery. Questo consente di fornire a ciascun
dispositivo l'elenco dei propri vicini e concentrare l'attenzione sul
\texttt{NetworkManager}, vero protagonista di questa fase.

Le applicazioni sono state sviluppate parallelamente in Java e in Kotlin,
utilizzando per entrambi un framework di testing, relativamente \textit{Junit} e
\textit{Kotlintest}. In seguito i test sono stati agganciati ad una pipeline di
continuous integration, offerta dal servizio gratuito
TravisCI\footnote{https://travis-ci.org/}.

Nelle sei simulazioni totali è stato riprodotto il medesimo scenario. In questo
modo si può notare come l'implementazione del backend sia completamente
trasparente al comportamento finale del sistema. Le seguenti simulazioni sono
eseguite su una rete di cinque dispositivi emulati, disposti secondo topologia
ad anello: ciascun dispositivo è quindi in grado
di comunicare solo con quello a sé adiacente.

\begin{minipage}{\linewidth}
\lstinputlisting[caption={Hello, World! in Protelis.},
label=lst:listato1]{code/hello.pt}
\end{minipage}

Il programma Protelis eseguito è un semplice HelloWorld (Listato
\ref{lst:hello-protelis}). Nella prima parte il leader effettua un conteggio a
ritroso. Nella seconda parte i dispositivi adiacenti al leader vengono salutati
da questo.

% Test svolti sempre uguale
%
% Numero di iterazioni
\section{Simulatore personalizzato}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/emulated-network-classes}
  \caption{Rappresentazione tramite diagramma UML delle classi della classe
    \texttt{EmulatedNetworkManager}. Essa contiente un insieme di
    \texttt{Device} vicini al \texttt{Device} a cui appartiene. Utilizza questi
    riferimenti per inviare loro messaggi.}
  \label{fig:emulated-network-classes}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/emulated-network-sequence}
  \caption{Rappresentazione attraverso un diagramma UML di sequenza l'uso
    dell'entità \texttt{EmulatedNetworkManager}.}
    \label{fig:emulated-network-sequence}
\end{figure}
La prima implementazione che è stata realizzata è un simulatore.
L'implementazione di Protelis già esistente in Alchemist, quella che utilizza
la libreria NASA World Wind e quella già esistente nel vecchio repository di
Protelis sono state la linea guida per lo sviluppo di questa versione, in
quanto le strategie di comunicazione sono pressoché le stesse.

In questa modalità i \texttt{Device} sono semplici oggetti eseguiti all'interno
della stessa Java Virtual Machine (Figura \ref{fig:simulation-deployment}). Ne
segue che ciascuno ha visibilità dell'altro in memoria e la comunicazione
avviene, come di consueto nella programmazione ad oggetti, tramite le chiamate
ai metodi; il contenuto dei messaggi è passato come argomento di questi ultimi.

Nello specifico è stata realizzata la classe \texttt{EmulatedNetworkManager},
che simula il comportamento che il \texttt{NetworkManager} avrebbe in una rete
reale. Ciascun \texttt{EmulatedNetworkManager} contiene una lista di
\texttt{Device} vicini(Figura \ref{fig:emulated-network-classes}). Il meccanismo
utilizzato per l'allineamento del codice in fase di esecuzione prevede lo
scambio di un oggetto di tipo \texttt{Map<CodePath, Object>}.
Questo viene passato attraverso un apposito metodo per ricevere un messaggio
dall'esterno, utilizzato nel momento in cui ad un dispositivo viene richiesto di
scambiare lo stato con altri dispositivi (Figura
\ref{fig:emulated-network-sequence}).
L'implementazione del \texttt{CodePath} scelta per questa versione è
\texttt{DefaultTimeEfficientCodePath}, in quanto la dimensione di questo oggetto
non è rilevante, poiché questo viene semplicemente referenziato in memoria,
senza necessità di effettuarne copie.

\section{Comunicazione su rete IP}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/socket-network-classes}
  \caption{Rappresentazione tramite diagramma UML delle classi dell'entità
    \texttt{SocketNetworkManager}.}
  \label{fig:socket-network-classes}
\end{figure}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/socket-network-sequence}
  \caption{Rappresentazione tramite diagramma UML di sequenza del comportamento
    della classe \texttt{SocketNetworkManager}.}
  \label{fig:socket-network-sequence}
\end{figure}
Questa versione realizza una versione distribuita del backend di Protelis.  È
stata fatta però una semplificazione rispetto a quanto descritto dal diagramma
presente nella Figura \ref{fig:distributed-deployment}): i \texttt{Device} non
sono eseguiti in macchine virtuali Java distinte. Per simulare il fatto che lo
siano essi non possono accedere a zone di memoria condivise, in particolare non
possono richiamare i rispettivi metodi. Per comunicare è necessario che essi
utilizzino metodi alternativi, per esempio che utilizzino la rete IP come
tramite.

In questo esempio il passaggio dell'oggetto \texttt{Map<CodePath, Object>}
avviene tramite l'utilizzo di socket TCP. Il protocollo
TCP\footnote{https://tools.ietf.org/html/rfc0793} è un protocollo di rete di
livello trasporto, orientato alla connessione, che utilizza un'architettura
client-server e che garantisce un canale affidabile di comunicazione tra due
applicazioni su host distinti. La comunicazione avviene nel seguente modo: un
server si mette in ascolto su una determinata porta; un client invia al server
una richiesta di connessione su quella porta. A questo punto il server accetta
la connessione e viene stabilito un canale di comunicazione affidabile, che può
essere utilizzato per lo scambio in entrambe le direzioni di flussi di dati. La
connessione può essere terminata in qualsiasi momento da uno degli host.

La classe che utilizza le socket è denominata \texttt{SocketNetworkManager}. In
questa versione ciascun \texttt{SocketNetworkManager} contiene al proprio
interno una lista di tuple nella forma \textit{(hostname, porta)}, che
rappresentano i vicini del dispositivo che lo contiene. Ciascuno di essi svolge
un duplice compito di server e client: il primo consiste nel rimanere in ascolto
di connessioni entranti per ricevere messaggi; il secondo comporta stabilire
connessioni con altri \texttt{SocketNetworkManager} quando deve inviare un
messaggio. Una volta che la connessione è stabilita il mittente invia l'oggetto
\texttt{Map<CodePath, Object>} al destinatario, che poi procede a memorizzarlo.

Per permettere il passaggio di un oggetto tramite un protocollo di rete è
necessario effettuare una serializzazione dell'oggetto, ovvero una conversione
dello stato di un oggetto in una serie di byte, cosicché questo possa essere
memorizzato o, in questo caso, trasferito tramite la rete sotto forma di stream
di dati. Una volta giunto a destinazione questo viene de-serializzato, in modo
da poter ricostruire un oggetto replica dell'originale. I principali metodi
utilizzabili per la serializzazione di oggetti sono: Protocol
Buffers\footnote{https://developers.google.com/protocol-buffers}, JSON, YAML,
Kryo\footnote{https://github.com/EsotericSoftware/kryo},
Elsa\footnote{https://github.com/jankotek/elsa}, etc.. In questa demo, per
motivi di semplificazione, è stata utilizzato il meccanismo di serializzazione
già presente in Java: l'interfaccia \texttt{Serializable}, che, per quanto non
efficiente come come le altre già citate, soddisfa pienamente le necessità del
progetto.

L'implementazione di \texttt{CodePath} utilizzata in questa demo è
\texttt{HashingCodePath}, in quanto l'oggetto necessita di essere serializzato e
trasferito successivamente tramite la rete. È conveniente dunque che la
dimensione finale di questo sia predicibile a priori.

\section{Protocolli orientati all'Internet-of-Things}
Come già ampiamente discusso, le caratteristiche della programmazione aggregata
forniscono una risposta eccellente alle richieste di campi in via di sviluppo
sempre maggiori, quali Internet-of-Things e reti di sensori, per esempio. È
importante che l'architettura definita possa supportare le tecnologie e i
protocolli utilizzati in questi ambiti, come MQTT\footnote{http://mqtt.org/},
Stomp\footnote{https://stomp.github.io/},
CoAP\footnote{https://coap.technology/}, etc.. In questa sezione viene mostrata
un'implementazione \texttt{NetworkManager} che sfrutta il protocollo MQTT, per
permettere al proprio dispositivo di comunicare con gli altri nodi della rete.

Il protocollo MQTT è un protocollo nato per l'utilizzo nell'ambito
Internet-of-Things e comunicazione \textit{machine-to-machine}, che risulta molto
efficiente nell'utilizzo della banda di connessione a disposizione. Utilizza il
modello \textit{publish/subscribe}. Questo prevede la presenza di un broker di
messaggistica, un nodo centrale attraverso il quale i client possono registrarsi
per essere notificati di determinati \textit{topic} (argomenti). In qualsiasi
momento un nodo può registrarsi a un nuovo argomento di interesse o inviare un
messaggio a uno di questi. Nel momento in cui il broker riceve un nuovo
messaggio relativo ad un argomento, notifica tutti i client che si erano
registrati ad esso in precedenza. Questo approccio consente di disaccoppiare la
produzione del messaggio dalla sua accettazione, rendendo la comunicazione
asincrona.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/mqtt-network-classes}
  \caption{Rappresentazione tramite diagramma UML delle classi dell'entità
    \texttt{MqttNetworkManager}.}
  \label{fig:emulated-network-classes}
\end{figure}

La classe che utilizza questo protocollo si chiama
\texttt{MqttNetworkManager}. Come la classe \texttt{SocketNetworkManager}
descritta in precedenza, anche questa ha una duplice funzione. La prima è quella
di essere a disposizione per ricevere messaggi: questo avviene mediante la
registrazione, presso un broker centrale, relativa ai messaggi destinati a sé
stesso. La seconda è quella di inviare messaggi agli altri nodi. Per fare questo
ciascun \texttt{MqttNetworkManager} contiene al proprio interno una lista di
argomenti a cui inviare messaggi, uno per ogni vicino; nel momento in cui gli
viene richiesto di inviare l'oggetto \texttt{Map<CodePath, Object>} agli altri
nodi esso lo invia, una volta per ogni argomento, dopo opportuna
serializzazione, al broker di messaggistica, che provvederà a diffondere il
messaggio ai rispettivi destinatari.

Anche in questa versione sono state fatte molte delle scelte effettuate per
quella precedente: i \texttt{Device} sono eseguiti all'interno della stessa Java
Virtual Machine, ma si comportano come se non lo fossero; il serializzatore
scelto è stato quello già predefinito in Java; l'implementazione di
\texttt{CodePath} utilizzata è la stessa, per la stessa ragione.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{diagrams/output/mqtt-network-sequence}
  \caption{Rappresentazione attraverso un diagramma UML di sequenza dell'uso
    della classe \texttt{MqttNetworkManager}. La fase di trasmissione di un
    messaggio è ripetuta per ogni dispositivo vicino.}
    .\label{fig:emulated-network-sequence}
\end{figure}